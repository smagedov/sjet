// Include necessary system headers
#include <iostream>
#include <random>

// Event structure for this analysis
#include "PythiaEvent.hh"

// Analysis sequencer
#include "FrameworkAnalysisSequence.hh"

// Event production and analysis modules
#include "PythiaEventMaker.hh"
#include "PythiaEventTTbarGen.hh"
//#include "MinimalEventPrinter.hh"
#include "EventCounter.hh"

// Utilities, etc
#include "tv_to_usec.hh"
#include "gnuc_demangle_type.hh"

// Command line procesing
#include "CmdLine.hh"

// Function for printing usage instructions
static void print_usage(const char* progname)
{
    std::cout << "\nUsage: " << progname
              << std::endl
              << "The following arguments must be provided on the command line:\n"
              << std::endl
              << " inputFile           Pythia configurature file.\n"
              << std::endl;
}

int main(int argc, char *argv[])
{
    //typedef std::mt19937_64 MyRng;
    typedef PythiaEvent MyEvent;
    typedef frw::FrameworkAnalysisSequence<MyEvent> MyAnalysis;

    // The convention is to print usage instructions and
    // exit with status 0 in case the program is run without
    // any command line arguments
    CmdLine cmdline(argc, argv);
    if (argc == 1)
    {
        print_usage(cmdline.progname());
        return 0;
    }

    // Parse command line arguments
    //double range;
    std::string inputFile;

    try {

        cmdline.optend();
        if (cmdline.argc() != 1)
            throw CmdLineError("wrong number of command line arguments");
	cmdline>>inputFile;
        // Basic checks of argument and option values
    }
    catch (const CmdLineError& e) {
        std::cerr << "Error in " << cmdline.progname() << ": "
                  << e.str() << std::endl;
        return 1;
    }

    // Print the command line arguments
    std::cout << "Command line: " << cmdline.progname();
    for (int iarg=1; iarg<argc; ++iarg)
        std::cout << ' ' << argv[iarg];
    std::cout << std::endl;
    
    // Storage space for the event data
    MyEvent evt;
    std::cout << "\nEvent type is \"" << gnuc_demangle_type(evt) << '"' << std::endl;
    std::cout << "Event version is " << evt.version() << std::endl;

    // Initialize the random number generator
    // Create the event generation and analysis sequence.
    // The "add" function of the FrameworkAnalysisSequence class
    // clones the framework modules. After that the original
    // modules should immediately go out of scope. This is because
    // modules could have unique and shared pointers as their members,
    // while copy constructors could be auto-generated by the compiler.
    // In such cases calling the destructors at the end of the
    // program (rather than immediately) could potentially have
    // undesired effects.
    MyAnalysis mySequence;
    mySequence.add(frw::EventCounter<MyEvent>("EventCounter 0"));
    mySequence.add(PythiaEventMaker<MyEvent>(
                       "PythiaEventMaker", inputFile));
    mySequence.add(PythiaEventTTbarGen<MyEvent>(
                       "PythiaEventTTbarGen"));
    mySequence.add(frw::EventCounter<MyEvent>("EventCounter 1"));

    // Print module labels in this analysis sequence
    std::cout << "Sequence of framework modules ("
              << mySequence.nModules() << " total):" << std::endl;
    for (const std::string& l : mySequence.labels())
        std::cout << l << std::endl;

    // Note the start time of the event loop
    struct timeval tv0;
    const int st0 = gettimeofday(&tv0, NULL);
    assert(st0 == 0);

    // Generate events and run the analysis code
    // (i.e., process the event loop)
    int nEvents=1;
    for (unsigned iev=0; iev<nEvents; ++iev)
    {
        evt.clear();
        evt.setNumber(iev);
        mySequence.run(evt);
    }

    // Measure the run time of the event loop
    struct timeval tv1;
    const int st1 = gettimeofday(&tv1, NULL);
    assert(st1 == 0);
    const double sec = (tv_to_usec(&tv1) - tv_to_usec(&tv0))/1.0e6;
    std::cout << "\nEvent cycle run time is " << sec << " sec / "
              << nEvents << " events" << std::endl;

    // Run the "endJob" methods of the framework modules
    std::cout << "\nReports from analysis modules:" << std::endl;
    mySequence.endJob();

    // We are done
    return 0;
}
