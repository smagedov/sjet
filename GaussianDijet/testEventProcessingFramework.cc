// Include necessary system headers
#include <iostream>
#include <random>

// Event structure for this analysis
#include "MinimalEvent.hh"

// Analysis sequencer
#include "FrameworkAnalysisSequence.hh"

// Event production and analysis modules
#include "MinimalEventMaker.hh"
#include "MinimalEventPrinter.hh"
#include "EventCounter.hh"

// Utilities, etc
#include "tv_to_usec.hh"
#include "gnuc_demangle_type.hh"

// Command line procesing
#include "CmdLine.hh"

// Function for printing usage instructions
static void print_usage(const char* progname)
{
    std::cout << "\nUsage: " << progname
              << " [--seed value] nEvents range outputFile\n"
              << std::endl
              << "The following options can be specified to modify the program behavior:\n"
              << std::endl
              << " --seed            This option allows you to provide the seed for the random\n"
              << "                   number generator. Default value of this option is 0 which\n"
              << "                   means that the seed will be chosen automatically (resulting\n"
              << "                   in a different set of events every time you run the\n"
              << "                   program). If you want to specify the seed, choose a large\n"
              << "                   prime number (but less than 2^64).\n"
              << std::endl
              << "The following arguments must be provided on the command line:\n"
              << std::endl
              << " nEvents           Number of events to generate and analyze.\n"
              << std::endl
              << " range             The random numbers will be uniform between 0.0 and this\n"
              << "                   range.\n"
              << std::endl
              << " outputFile        The name of the file into which the random numbers will be\n"
              << "                   written in a text form.\n"
              << std::endl;
}

int main(int argc, char *argv[])
{
    typedef std::mt19937_64 MyRng;
    typedef MinimalEvent MyEvent;
    typedef frw::FrameworkAnalysisSequence<MyEvent> MyAnalysis;

    // The convention is to print usage instructions and
    // exit with status 0 in case the program is run without
    // any command line arguments
    CmdLine cmdline(argc, argv);
    if (argc == 1)
    {
        print_usage(cmdline.progname());
        return 0;
    }

    // Parse command line arguments
    unsigned long seed = 0;
    double range;
    std::string outputFile;
    unsigned nEvents;

    try {
        cmdline.option(0, "--seed") >> seed;

        cmdline.optend();
        if (cmdline.argc() != 3)
            throw CmdLineError("wrong number of command line arguments");
        cmdline >> nEvents >> range >> outputFile;

        // Basic checks of argument and option values
        if (range <= 0.0)
            throw CmdLineError("range parameter must be positive");
    }
    catch (const CmdLineError& e) {
        std::cerr << "Error in " << cmdline.progname() << ": "
                  << e.str() << std::endl;
        return 1;
    }

    // Print the command line arguments
    std::cout << "Command line: " << cmdline.progname();
    for (int iarg=1; iarg<argc; ++iarg)
        std::cout << ' ' << argv[iarg];
    std::cout << std::endl;
    
    // Storage space for the event data
    MyEvent evt;
    std::cout << "\nEvent type is \"" << gnuc_demangle_type(evt) << '"' << std::endl;
    std::cout << "Event version is " << evt.version() << std::endl;

    // Initialize the random number generator
    unsigned long actualSeed = seed;
    if (!seed)
    {
        std::random_device rd;
        actualSeed = rd();
    }
    std::cout << "\nRng seed is " << actualSeed
              << (seed ? "" : " (auto)") << "\n\n";
    MyRng gen(actualSeed);

    // Create the event generation and analysis sequence.
    // The "add" function of the FrameworkAnalysisSequence class
    // clones the framework modules. After that the original
    // modules should immediately go out of scope. This is because
    // modules could have unique and shared pointers as their members,
    // while copy constructors could be auto-generated by the compiler.
    // In such cases calling the destructors at the end of the
    // program (rather than immediately) could potentially have
    // undesired effects.
    MyAnalysis mySequence;
    mySequence.add(frw::EventCounter<MyEvent>("EventCounter 0"));
    mySequence.add(MinimalEventMaker<MyEvent,MyRng>(
                       "MinimalEventMaker", gen, range));
    mySequence.add(frw::EventCounter<MyEvent>("EventCounter 1"));
    mySequence.add(MinimalEventPrinter<MyEvent>(
                       "MinimalEventPrinter", outputFile));
    mySequence.add(frw::EventCounter<MyEvent>("EventCounter 2"));

    // Print module labels in this analysis sequence
    std::cout << "Sequence of framework modules ("
              << mySequence.nModules() << " total):" << std::endl;
    for (const std::string& l : mySequence.labels())
        std::cout << l << std::endl;

    // Note the start time of the event loop
    struct timeval tv0;
    const int st0 = gettimeofday(&tv0, NULL);
    assert(st0 == 0);

    // Generate events and run the analysis code
    // (i.e., process the event loop)
    for (unsigned iev=0; iev<nEvents; ++iev)
    {
        evt.clear();
        evt.setNumber(iev);
        mySequence.run(evt);
    }

    // Measure the run time of the event loop
    struct timeval tv1;
    const int st1 = gettimeofday(&tv1, NULL);
    assert(st1 == 0);
    const double sec = (tv_to_usec(&tv1) - tv_to_usec(&tv0))/1.0e6;
    std::cout << "\nEvent cycle run time is " << sec << " sec / "
              << nEvents << " events" << std::endl;

    // Run the "endJob" methods of the framework modules
    std::cout << "\nReports from analysis modules:" << std::endl;
    mySequence.endJob();

    // We are done
    return 0;
}
